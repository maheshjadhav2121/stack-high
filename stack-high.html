<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Stack High üèóÔ∏è</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Titan+One&family=Nunito:wght@700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #38bdf8;
        font-family: "Nunito", sans-serif;
        touch-action: none; /* Prevent zoom/scroll on mobile */
      }
      canvas {
        display: block;
      }
      .title-font {
        font-family: "Titan One", cursive;
        text-shadow: 4px 4px 0px #78350f;
        -webkit-text-stroke: 2px #fff;
      }
      .ui-shadow {
        text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
      }
      .btn-3d {
        transition: all 0.1s;
        box-shadow: 0px 6px 0px 0px #15803d;
      }
      .btn-3d:active {
        transform: translateY(6px);
        box-shadow: 0px 0px 0px 0px #15803d;
      }
      /* Specific Difficulty Colors */
      .diff-easy {
        color: #4ade80;
        text-shadow: 2px 2px 0 #14532d;
        -webkit-text-stroke: 1px white;
      }
      .diff-med {
        color: #facc15;
        text-shadow: 2px 2px 0 #713f12;
        -webkit-text-stroke: 1px white;
      }
      .diff-hard {
        color: #ef4444;
        text-shadow: 2px 2px 0 #7f1d1d;
        -webkit-text-stroke: 1px white;
      }

      .shake {
        animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
      }
      @keyframes shake {
        10%,
        90% {
          transform: translate3d(-4px, 0, 0);
        }
        20%,
        80% {
          transform: translate3d(4px, 0, 0);
        }
        30%,
        50%,
        70% {
          transform: translate3d(-8px, 0, 0);
        }
        40%,
        60% {
          transform: translate3d(8px, 0, 0);
        }
      }
    </style>
  </head>
  <body class="relative h-screen w-screen text-white select-none">
    <canvas
      id="gameCanvas"
      class="absolute top-0 left-0 w-full h-full"
    ></canvas>

    <!-- UI Overlay Layer -->
    <div
      id="uiLayer"
      class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10"
    >
      <!-- HUD -->
      <div
        id="hud"
        class="flex justify-between items-start opacity-0 transition-opacity duration-300 w-full max-w-2xl mx-auto"
      >
        <!-- Score -->
        <div class="flex flex-col">
          <span
            class="text-sm uppercase tracking-wider ui-shadow font-bold text-yellow-300"
            >Score</span
          >
          <span
            id="scoreDisplay"
            class="text-4xl font-black title-font text-white"
            style="-webkit-text-stroke: 1px #166534"
            >0</span
          >
        </div>

        <!-- Difficulty Display -->
        <div class="flex flex-col items-center pt-2">
          <div
            class="bg-black/30 backdrop-blur-md rounded-xl px-4 py-2 border border-white/20 shadow-lg"
          >
            <span
              class="text-xs text-gray-200 uppercase tracking-widest block text-center mb-1"
              >Difficulty</span
            >
            <span
              id="difficultyDisplay"
              class="text-2xl font-black title-font diff-easy tracking-wide"
              >EASY</span
            >
          </div>
        </div>

        <!-- Best Score -->
        <div class="flex flex-col items-end">
          <span
            class="text-sm uppercase tracking-wider ui-shadow font-bold text-yellow-300"
            >Best</span
          >
          <span id="bestDisplay" class="text-2xl font-bold ui-shadow">0</span>
        </div>
      </div>

      <!-- Start Screen -->
      <div
        id="startScreen"
        class="absolute inset-0 flex flex-col items-center justify-center bg-black/40 backdrop-blur-sm pointer-events-auto transition-opacity duration-300 z-20"
      >
        <div class="relative mb-8 animate-bounce">
          <div class="absolute -top-12 -left-12 text-5xl animate-pulse">üß±</div>
          <h1
            class="text-6xl md:text-8xl text-yellow-400 title-font tracking-wider text-center"
          >
            STACK<br />HIGH
          </h1>
          <div
            class="absolute -bottom-8 -right-8 text-5xl animate-pulse delay-75"
          >
            üèóÔ∏è
          </div>
        </div>

        <p class="text-xl mb-8 font-bold text-white ui-shadow animate-pulse">
          Tap anywhere to drop!
        </p>

        <button
          id="startBtn"
          class="btn-3d bg-green-500 hover:bg-green-400 text-white text-2xl font-black py-4 px-12 rounded-2xl border-b-4 border-green-700 pointer-events-auto transition-transform"
        >
          PLAY NOW üèóÔ∏è
        </button>

        <div class="mt-8 flex gap-4 text-3xl opacity-80">
          <span>üì¶</span><span>üè¢</span><span>üåá</span>
        </div>
      </div>

      <!-- Game Over Screen -->
      <div
        id="gameOverScreen"
        class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/60 backdrop-blur-md pointer-events-auto z-50"
      >
        <h2 class="text-5xl md:text-7xl text-red-500 title-font mb-2">OOPS!</h2>
        <p class="text-2xl text-white font-bold mb-6 ui-shadow">
          The tower fell.
        </p>

        <div
          class="bg-white/10 rounded-xl p-6 mb-8 text-center backdrop-blur-md border border-white/20 w-64 shadow-2xl"
        >
          <div class="mb-4">
            <p class="text-sm uppercase tracking-widest text-gray-300">
              Final Score
            </p>
            <p
              id="finalScore"
              class="text-5xl font-black text-yellow-400 title-font drop-shadow-md"
            >
              0
            </p>
          </div>
          <div>
            <p class="text-sm uppercase tracking-widest text-gray-300">
              Difficulty Reached
            </p>
            <p id="finalDiff" class="text-xl font-bold text-white mt-1">EASY</p>
          </div>
        </div>

        <button
          id="retryBtn"
          class="btn-3d bg-blue-500 hover:bg-blue-400 text-white text-xl font-black py-4 px-10 rounded-2xl border-b-4 border-blue-700 pointer-events-auto"
        >
          TRY AGAIN üîÑ
        </button>
      </div>

      <!-- Combo Text Container -->
      <div
        id="comboContainer"
        class="absolute top-1/4 left-1/2 transform -translate-x-1/2 pointer-events-none text-center w-full z-30"
      ></div>
    </div>

    <script>
      class SoundManager {
        constructor() {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.value = 0.3;
          this.masterGain.connect(this.ctx.destination);
        }

        init() {
          if (this.ctx.state === "suspended") {
            this.ctx.resume();
          }
        }

        playTone(freq, type, duration, slideFreq = null) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          if (slideFreq)
            osc.frequency.exponentialRampToValueAtTime(
              slideFreq,
              this.ctx.currentTime + duration
            );
          gain.gain.setValueAtTime(1, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            this.ctx.currentTime + duration
          );
          osc.connect(gain);
          gain.connect(this.masterGain);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        }

        playThud() {
          this.playTone(100, "square", 0.1, 50);
        }
        playPerfect(combo) {
          const notes = [523.25, 587.33, 659.25, 783.99, 880.0, 1046.5];
          const note = notes[Math.min(combo, notes.length - 1)];
          this.playTone(note, "sine", 0.3);
          this.playTone(note * 2, "triangle", 0.1);
        }
        playCut() {
          this.playTone(200, "sawtooth", 0.1, 100);
        }
        playGameOver() {
          this.playTone(400, "sawtooth", 0.8, 50);
          setTimeout(() => this.playTone(350, "square", 0.8, 40), 200);
        }
      }

      const CONFIG = {
        blockHeight: 45, // Slightly taller for better touch target feel
        baseWidth: 220,
        bgTop: "#60A5FA", // Slightly deeper blue
        bgBottom: "#BAE6FD",
        colors: [
          "#EF4444",
          "#F97316",
          "#EAB308",
          "#22C55E",
          "#06B6D4",
          "#8B5CF6",
          "#EC4899",
        ],
        perfectTolerance: 6,
        minBlockWidth: 15, // Game over if block gets smaller than this
        difficulty: {
          easy: { threshold: 0, speed: 4, label: "EASY", class: "diff-easy" },
          medium: {
            threshold: 10,
            speed: 7,
            label: "MEDIUM",
            class: "diff-med",
          },
          hard: { threshold: 25, speed: 11, label: "HARD", class: "diff-hard" },
        },
      };

      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.color = color;
          this.vx = (Math.random() - 0.5) * 10;
          this.vy = (Math.random() - 0.5) * 10;
          this.life = 1.0;
          this.decay = Math.random() * 0.03 + 0.02;
          this.size = Math.random() * 6 + 2;
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.3;
          this.life -= this.decay;
        }
        draw(ctx) {
          ctx.globalAlpha = Math.max(0, this.life);
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
      }

      class Debris {
        constructor(x, y, width, height, color) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.color = color;
          this.vx = 0;
          this.vy = 0;
          this.rotation = 0;
          this.rotSpeed = (Math.random() - 0.5) * 0.2;
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.6;
          this.rotation += this.rotSpeed;
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
          ctx.rotate(this.rotation);
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.roundRect(
            -this.width / 2,
            -this.height / 2,
            this.width,
            this.height,
            4
          );
          ctx.fill();
          ctx.restore();
        }
      }

      class Cloud {
        constructor(canvasWidth, canvasHeight) {
          this.reset(canvasWidth, canvasHeight, true);
        }
        reset(cw, ch, randomX = false) {
          this.x = randomX ? Math.random() * cw : -150;
          this.y = Math.random() * (ch * 0.7);
          this.speed = Math.random() * 0.3 + 0.1;
          this.scale = Math.random() * 0.6 + 0.4;
          this.cw = cw;
        }
        update() {
          this.x += this.speed;
          if (this.x > this.cw + 150) this.reset(this.cw, 1000, false);
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.scale(this.scale, this.scale);
          ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
          ctx.beginPath();
          ctx.arc(0, 0, 40, 0, Math.PI * 2);
          ctx.arc(35, -15, 45, 0, Math.PI * 2);
          ctx.arc(35, 15, 45, 0, Math.PI * 2);
          ctx.arc(70, 0, 40, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      class Game {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.audio = new SoundManager();

          // UI Elements
          this.startScreen = document.getElementById("startScreen");
          this.gameOverScreen = document.getElementById("gameOverScreen");
          this.hud = document.getElementById("hud");
          this.scoreDisplay = document.getElementById("scoreDisplay");
          this.bestDisplay = document.getElementById("bestDisplay");
          this.diffDisplay = document.getElementById("difficultyDisplay");
          this.comboContainer = document.getElementById("comboContainer");

          // Game State
          this.isPlaying = false;
          this.score = 0;
          this.highScore = localStorage.getItem("stackHigh_best") || 0;
          this.blocks = [];
          this.debris = [];
          this.particles = [];
          this.clouds = [];
          this.currentDiff = CONFIG.difficulty.easy;

          // Physics State
          this.currentBlock = null;
          this.direction = 1;
          this.cameraY = 0;
          this.targetCameraY = 0;
          this.combo = 0;
          this.time = 0;

          this.resize();
          window.addEventListener("resize", () => this.resize());

          const handleInput = (e) => {
            if (this.isPlaying && e.target.tagName !== "BUTTON") {
              e.preventDefault();
              this.dropBlock();
            }
          };

          window.addEventListener("mousedown", handleInput);
          window.addEventListener("touchstart", handleInput, {
            passive: false,
          });

          document
            .getElementById("startBtn")
            .addEventListener("click", () => this.start());
          document
            .getElementById("retryBtn")
            .addEventListener("click", () => this.restart());

          for (let i = 0; i < 8; i++) {
            this.clouds.push(new Cloud(this.canvas.width, this.canvas.height));
          }

          this.bestDisplay.innerText = this.highScore;
          this.drawBackground();
          this.loop();
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          this.targetCameraY = 0;
        }

        updateDifficulty() {
          let newDiff = CONFIG.difficulty.easy;

          if (this.score >= CONFIG.difficulty.hard.threshold) {
            newDiff = CONFIG.difficulty.hard;
          } else if (this.score >= CONFIG.difficulty.medium.threshold) {
            newDiff = CONFIG.difficulty.medium;
          }

          if (this.currentDiff !== newDiff) {
            this.currentDiff = newDiff;
            // Flash effect on UI
            this.diffDisplay.parentElement.classList.add("animate-pulse");
            setTimeout(
              () =>
                this.diffDisplay.parentElement.classList.remove(
                  "animate-pulse"
                ),
              1000
            );
          }

          this.diffDisplay.innerText = this.currentDiff.label;
          this.diffDisplay.className = `text-2xl font-black title-font tracking-wide ${this.currentDiff.class}`;
        }

        start() {
          this.audio.init();
          this.isPlaying = true;
          this.score = 0;
          this.combo = 0;
          this.blocks = [];
          this.debris = [];
          this.particles = [];
          this.cameraY = 0;
          this.targetCameraY = 0;
          this.direction = 1;
          this.time = 0;
          this.currentDiff = CONFIG.difficulty.easy;

          const baseBlock = {
            x: (this.canvas.width - CONFIG.baseWidth) / 2,
            y: this.canvas.height - 150,
            width: CONFIG.baseWidth,
            height: CONFIG.blockHeight,
            color: CONFIG.colors[0],
            placed: true,
          };
          this.blocks.push(baseBlock);

          this.spawnNextBlock();

          this.startScreen.style.opacity = "0";
          this.startScreen.style.pointerEvents = "none";
          this.gameOverScreen.classList.add("hidden");
          this.hud.style.opacity = "1";
          this.updateUI();
        }

        restart() {
          this.gameOverScreen.classList.add("hidden");
          this.start();
        }

        spawnNextBlock() {
          const prevBlock = this.blocks[this.blocks.length - 1];
          const colorIndex = this.blocks.length % CONFIG.colors.length;

          // Difficulty Speed Calculation
          let targetSpeed = this.currentDiff.speed;
          // Add slight increment within the difficulty tier
          targetSpeed += (this.score - this.currentDiff.threshold) * 0.1;

          this.speed = targetSpeed;

          this.currentBlock = {
            x: -prevBlock.width,
            y: prevBlock.y - CONFIG.blockHeight,
            width: prevBlock.width,
            height: CONFIG.blockHeight,
            color: CONFIG.colors[colorIndex],
            placed: false,
          };

          if (this.blocks.length % 2 === 0) {
            this.currentBlock.x = -this.currentBlock.width - 50;
            this.direction = 1;
          } else {
            this.currentBlock.x = this.canvas.width + 50;
            this.direction = -1;
          }
        }

        dropBlock() {
          if (!this.currentBlock || this.currentBlock.placed) return;

          const prevBlock = this.blocks[this.blocks.length - 1];
          const curr = this.currentBlock;
          curr.placed = true;

          const dist = curr.x - prevBlock.x;
          const absDist = Math.abs(dist);

          if (absDist >= curr.width || curr.width < CONFIG.minBlockWidth) {
            this.gameOver();
            return;
          }

          if (absDist < CONFIG.perfectTolerance) {
            curr.x = prevBlock.x;
            this.combo++;
            this.score += 2 + Math.floor(this.combo / 2);
            this.audio.playPerfect(this.combo);
            this.spawnParticles(
              curr.x + curr.width / 2,
              curr.y + curr.height / 2,
              curr.color,
              20
            );
            this.showComboText("PERFECT! x" + this.combo);

            // Minor reward: Grow block slightly on perfect streak (capped)
            if (this.combo > 2 && curr.width < CONFIG.baseWidth) {
              curr.width += 5;
              curr.x -= 2.5; // Center growth
            }
          } else {
            this.combo = 0;
            this.score++;
            this.audio.playCut();

            const overlap = curr.width - absDist;

            if (overlap < CONFIG.minBlockWidth) {
              this.gameOver();
              return;
            }

            if (dist > 0) {
              curr.width = overlap;
              this.spawnDebris(
                curr.x + curr.width,
                curr.y,
                absDist,
                curr.height,
                curr.color,
                1
              );
            } else {
              curr.x = prevBlock.x;
              curr.width = overlap;
              this.spawnDebris(
                prevBlock.x - absDist,
                curr.y,
                absDist,
                curr.height,
                curr.color,
                -1
              );
            }
            this.audio.playThud();
          }

          this.blocks.push(curr);

          if (this.blocks.length > 3) {
            this.targetCameraY = (this.blocks.length - 3) * CONFIG.blockHeight;
          }

          this.updateDifficulty();
          this.updateUI();
          this.spawnNextBlock();
        }

        spawnDebris(x, y, w, h, color, direction) {
          const d = new Debris(x, y, w, h, color);
          d.vx = direction * (4 + Math.random() * 2);
          d.vy = -6;
          this.debris.push(d);
        }

        spawnParticles(x, y, color, count) {
          for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, color));
          }
        }

        showComboText(text) {
          const el = document.createElement("div");
          el.className =
            "text-5xl font-black text-yellow-300 title-font animate-bounce absolute w-full drop-shadow-xl";
          el.style.textShadow = "3px 3px 0 #000";
          el.innerText = text;
          this.comboContainer.appendChild(el);
          setTimeout(() => el.remove(), 1000);
        }

        gameOver() {
          this.isPlaying = false;

          const fallingBlock = new Debris(
            this.currentBlock.x,
            this.currentBlock.y,
            this.currentBlock.width,
            this.currentBlock.height,
            this.currentBlock.color
          );
          fallingBlock.vy = 8;
          fallingBlock.vx = this.direction * 2;
          this.debris.push(fallingBlock);
          this.currentBlock = null;

          document.body.classList.add("shake");
          setTimeout(() => document.body.classList.remove("shake"), 500);

          this.audio.playGameOver();

          if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem("stackHigh_best", this.highScore);
          }

          setTimeout(() => {
            document.getElementById("finalScore").innerText = this.score;
            document.getElementById("finalDiff").innerText =
              this.currentDiff.label;
            document.getElementById("finalDiff").className =
              "text-xl font-black mt-1 " + this.currentDiff.class;
            this.gameOverScreen.classList.remove("hidden");
            this.hud.style.opacity = "0";
          }, 800);
        }

        updateUI() {
          this.scoreDisplay.innerText = this.score;
        }

        update() {
          this.time += 0.05;
          this.clouds.forEach((c) => c.update());

          this.debris.forEach((d, i) => {
            d.update();
            if (d.y > this.canvas.height + this.cameraY + 100) {
              this.debris.splice(i, 1);
            }
          });

          this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
          });

          this.cameraY += (this.targetCameraY - this.cameraY) * 0.08; // Smoother camera

          if (
            this.isPlaying &&
            this.currentBlock &&
            !this.currentBlock.placed
          ) {
            this.currentBlock.x += this.speed * this.direction;
            // Bounding Logic
            if (this.currentBlock.x > this.canvas.width) {
              this.direction = -1;
            } else if (this.currentBlock.x + this.currentBlock.width < 0) {
              this.direction = 1;
            }
          }
        }

        drawBackground() {
          const ctx = this.ctx;
          const w = this.canvas.width;
          const h = this.canvas.height;

          const gradient = ctx.createLinearGradient(0, 0, 0, h);
          gradient.addColorStop(0, CONFIG.bgTop);
          gradient.addColorStop(1, CONFIG.bgBottom);
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, w, h);

          this.clouds.forEach((c) => c.draw(ctx));

          ctx.save();
          ctx.translate(0, this.cameraY);
          // Ground
          ctx.fillStyle = "#4ADE80";
          ctx.fillRect(0, h - 100, w, h + 500);

          // Darker grass top
          ctx.fillStyle = "#15803D";
          ctx.fillRect(0, h - 100, w, 15);
          ctx.restore();
        }

        drawBlock(block) {
          const ctx = this.ctx;

          // 1. Shadow
          ctx.shadowColor = "rgba(0,0,0,0.15)";
          ctx.shadowBlur = 15;
          ctx.shadowOffsetY = 8;

          // 2. Base Shape with Gradient
          const grad = ctx.createLinearGradient(
            block.x,
            block.y,
            block.x,
            block.y + block.height
          );
          grad.addColorStop(0, block.color);
          grad.addColorStop(1, this.adjustColor(block.color, -20)); // Darken bottom

          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.roundRect(block.x, block.y, block.width, block.height, 8);
          ctx.fill();

          // Clear shadow for details
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.shadowOffsetY = 0;

          // 3. Inner Bevel/Highlight
          ctx.fillStyle = "rgba(255,255,255,0.25)";
          ctx.beginPath();
          ctx.roundRect(
            block.x + 3,
            block.y + 3,
            block.width - 6,
            block.height / 2 - 3,
            5
          );
          ctx.fill();

          // 4. Eyes on top block
          if (block === this.blocks[this.blocks.length - 1] && this.isPlaying) {
            let eyeOffset = 0;
            if (this.currentBlock) {
              const centerStack = block.x + block.width / 2;
              const centerFall =
                this.currentBlock.x + this.currentBlock.width / 2;
              eyeOffset = (centerFall - centerStack) / 40;
              eyeOffset = Math.max(-5, Math.min(5, eyeOffset));
            }

            const eyeY = block.y + block.height * 0.4;

            // Whites
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(
              block.x + block.width * 0.3 + eyeOffset,
              eyeY,
              5,
              0,
              Math.PI * 2
            );
            ctx.arc(
              block.x + block.width * 0.7 + eyeOffset,
              eyeY,
              5,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Pupils
            ctx.fillStyle = "#1F2937";
            ctx.beginPath();
            ctx.arc(
              block.x + block.width * 0.3 + eyeOffset + this.direction,
              eyeY,
              2,
              0,
              Math.PI * 2
            );
            ctx.arc(
              block.x + block.width * 0.7 + eyeOffset + this.direction,
              eyeY,
              2,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Cute blush
            ctx.fillStyle = "rgba(255,0,0,0.1)";
            ctx.beginPath();
            ctx.arc(
              block.x + block.width * 0.3 + eyeOffset,
              eyeY + 6,
              3,
              0,
              Math.PI * 2
            );
            ctx.arc(
              block.x + block.width * 0.7 + eyeOffset,
              eyeY + 6,
              3,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }

        // Helper to darken hex color for gradient
        adjustColor(color, amount) {
          return (
            "#" +
            color
              .replace(/^#/, "")
              .replace(/../g, (color) =>
                (
                  "0" +
                  Math.min(
                    255,
                    Math.max(0, parseInt(color, 16) + amount)
                  ).toString(16)
                ).substr(-2)
              )
          );
        }

        draw() {
          const ctx = this.ctx;
          ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          this.drawBackground();

          ctx.save();
          ctx.translate(0, this.cameraY);

          this.blocks.forEach((block) => this.drawBlock(block));

          if (this.currentBlock && this.isPlaying) {
            this.drawBlock(this.currentBlock);
          }

          this.debris.forEach((d) => d.draw(ctx));
          this.particles.forEach((p) => p.draw(ctx));

          ctx.restore();

          // Vignette Overlay
          const grad = ctx.createRadialGradient(
            this.canvas.width / 2,
            this.canvas.height / 2,
            this.canvas.height / 2,
            this.canvas.width / 2,
            this.canvas.height / 2,
            this.canvas.height
          );
          grad.addColorStop(0, "transparent");
          grad.addColorStop(1, "rgba(0,0,0,0.15)");
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        loop() {
          this.update();
          this.draw();
          requestAnimationFrame(() => this.loop());
        }
      }

      window.onload = () => {
        const game = new Game();
      };
    </script>
  </body>
</html>
